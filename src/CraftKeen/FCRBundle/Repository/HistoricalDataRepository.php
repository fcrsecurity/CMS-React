<?php

namespace CraftKeen\FCRBundle\Repository;

use CraftKeen\FCRBundle\Entity\HistoricalData;
use Doctrine\ORM\EntityManager;

/**
 * HistoricalDataRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class HistoricalDataRepository extends \Doctrine\ORM\EntityRepository
{
    public function truncate()
    {
        $cmd = $this->getEntityManager()->getClassMetadata(HistoricalData::class);
        return $this->getEntityManager()
            ->getConnection()
            ->query('START TRANSACTION; SET FOREIGN_KEY_CHECKS=0; TRUNCATE '.$cmd->getTableName().'; SET FOREIGN_KEY_CHECKS=1; COMMIT;');
    }
    
    public function findByFrequency( $frequency='daily', $filters = [], $offset, $limit=0) {  
        date_default_timezone_set('America/Toronto');
        $fromDate = new \DateTime();// Now 
        $toDate = new \DateTime();// Now 
        $interval = new \DateInterval('P1D');// Default Interval 1D
        if (isset($filters['timeFrame'])) {
            if (in_array($filters['timeFrame'], ['1D','5D','1M','3M','6M','1Y','2Y','5Y','10Y'])) {
                $interval = new \DateInterval('P'.(string)$filters['timeFrame']);
            } elseif ($filters['timeFrame'] == 'YTD') {
                // Year to date
                $fromDate = new \DateTime($toDate->format('Y')."-01-01");
            } else {
                $interval = new \DateInterval('P15Y'); // TODO: Think of something better than 15 Years of FCR from now =)
            }
        }
        $fromDate->sub($interval);

        if (isset($filters['fromDate']) && isset($filters['toDate'])) {
            $fromDate = new \DateTime($filters['fromDate'] );
            $toDate = new \DateTime( $filters['toDate'] );
        } 
                
        $q = $this->createQueryBuilder('p')   
                ->orderBy('p.date', 'DESC')  
                ->where('p.date BETWEEN :fromDate AND :toDate')
                ->setParameter('fromDate', $fromDate->format('Y-m-d'))
                ->setParameter('toDate', $toDate->format('Y-m-d'));
                if ( (int)$offset > 0 ) {
                    $q->setFirstResult($offset);
                }
                if ( (int)$limit > 0 ) {
                    $q->setMaxResults($limit);
                }
                
        return $q->getQuery()->getResult(\Doctrine\ORM\AbstractQuery::HYDRATE_ARRAY);                
    }

    /**
     * Updates historical prices database. Must implemented daily
     *
     * @param array $latestValues
     * @return void
     */
    public function update( $latestValues )
    {
        /** @var EntityManager $em */
        $em = $this->getEntityManager();
        $q = $this->createQueryBuilder('p')
            ->orderBy('p.date', 'DESC');
        $q->setMaxResults(1);
        $latestLocalValue = $q->getQuery()->getOneOrNullResult();

        foreach ($latestValues as $value) {
            if ( $value['lastTrade']->format('H') == '16' && $value['lastTrade'] > $latestLocalValue->getDate() ) {
                $historicalPrice = new HistoricalData();
                $historicalPrice->setDate( $value['lastTrade'] );
                $historicalPrice->setAdjClose(null); // not in use
                $historicalPrice->setClose($value['lastPrice']);
                $historicalPrice->setHigh($value['dayHigh']);
                $historicalPrice->setLow($value['dayLow']);
                $historicalPrice->setOpen($value['openPrice']);
                $historicalPrice->setVolume($value['volume']);
                $em->persist($historicalPrice);

            }
        }
        $em->flush();
    }
}
